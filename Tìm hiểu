üü¢ I. Ng√¥n ng·ªØ C# c∆° b·∫£n
1. C·∫•u tr√∫c ch∆∞∆°ng tr√¨nh C#
##Main() method
  -L√† ƒëi·ªÉm b·∫Øt ƒë·∫ßu c·ªßa tr∆∞∆°ng tr√¨nh C#:
      using System;
      
      namespace HelloWorldApp
      {
          class Program
          {
              static void Main(string[] args)
              {
                  Console.WriteLine("Hello, World!");
              }
          }
      }
-Khai b√°o trong 1 class;
-L√† 1 h√†m static t√™n Main-> do l√† static n√™n ko c·∫ßn kh·ªüi t·∫°o, c·ª© th·∫ø g·ªçi d√πng th√¥i
-Tham s·ªë truy·ªÅn v√†o string[] arg, c√≥ th·ªÉ ko c√≥ tham s·ªë Main(), tham s·ªë ch·ªâ c√≥ √Ω nghƒ©a khi ch·∫°y ch∆∞∆°ng tr√¨nh v·ªõi command d√≤ng l·ªánh dotnet arg1 arg2... ho·∫∑c c√†i ƒë·∫∑t trong IDE
-Ch·ªâ cho ph√©p tr·∫£ v·ªÅ void ho·∫∑c int, tr·∫£ v·ªÅ int ƒë·ªÉ th·ªÉ hi·ªán m√£ l·ªói th·ª±c hi·ªán ch∆∞∆°ng tr√¨nh-quy ∆∞·ªõc m√£ v·ªõi user
##using directives:
  using +<namespace>: sau ƒë√≥ ch∆∞∆°ng tr√¨nh c√≥ th·ªÉ s·ª≠ d·ª•ng t·∫•t c·∫£ c√°c th√†nh ph·∫ßn public trong namspace ƒë√≥: class, interface, struct, enum...
  m√† ko c·∫ßn g·ªçi t∆∞·ªùng m√¨nh System.XYZ

##Namespace, class
-Namespace nh∆∞ l√† th∆∞ m·ª•c ch√∫a, gom nh√≥m c√°c class, interface...
-Class l√† m·ªôt khu√¥n m·∫´u (template) ƒë·ªÉ t·∫°o ra ƒë·ªëi t∆∞∆°ng, m√¥ h√¨nh h√≥a c·ªßa m·ªôt ƒë·ªëi t∆∞·ª£ng c·ª• th·ªÉ.

2. Ki·ªÉu d·ªØ li·ªáu c∆° b·∫£n
##int, float, double, bool, char, string, decimal

##var (ki·ªÉu suy lu·∫≠n): tr√¨nh bi·ªán d·ªãch t·ª± suy ra ki·ªÉu d·ªØ li·ªáu sau khi g√°n v·ªõi gi√° tr·ªã(x√°c ƒë·ªãnh ki·ªÉu t·∫°i compile time), ph·∫£i g√°n gi√° tr·ªã ngay khi khai b√°o v√¨ n√≥ l√† t∆∞·ªùng m√¨nh ko ph·∫£i dynamic.
  -Sau khi tr√¨nh bi√™n d·ªãch d·ª±a v√†o gi√° tr·ªã m√† x√°c ƒë·ªãnh ƒë∆∞·ª£c ki·ªÉu d·ªØ li·ªáu, th√¨ ki·ªÉu d·ªØ li·ªáu ƒë√≥ ko th·ªÉ thay ƒë·ªïi ƒë∆∞·ª£c n·ªØa
  vd: var x=12; => x l√† ki·ªÉu interger, c·ªë t√¨nh g√°n x="abc" ki·ªÉu string-> l·ªói v√¨ x ƒë√£ nh·∫≠n l√† ki·ªÉu int r·ªìi;
##dynamic: ki·ªÉu d·ªØ li·ªáu ƒë∆∞·ª£c x√°c ƒë·ªãnh t·∫°i runtime, linh ho·∫°t nh∆∞ng d·ªÖ g√¢y l·ªói runtime.
  D√πng khi x·ª≠ l√Ω d·ªØ li·ªáu ko bi·∫øt tr∆∞·ªõc c·∫•u tr√∫c: Json

  using Newtonsoft.Json;
  string json = "{ \"name\": \"Hai\", \"age\": 25, \"isActive\": true }";
  dynamic data = JsonConvert.DeserializeObject<dynamic>(json);  
  // Truy c·∫≠p tr·ª±c ti·∫øp m√† kh√¥ng c·∫ßn class
  Console.WriteLine(data.name);      // "Hai"
  Console.WriteLine(data.age);       // 25
  Console.WriteLine(data.isActive);  // true
  -T·∫°i runtime ko r√µ l√† ki·ªÉu d·ªØ li·ªáu ntn, ->Kh√¥ng c·∫ßn t·∫°o class User v·∫´n c√≥ th·ªÉ s·ª≠ d·ª•ng ƒë∆∞·ª£c c√°c field nam,age,isActice
  -Khi ch·∫°y c√≥ th·ªÉ g√°n l·∫°i cho nhi·ªÅu gi√° tr·ªã kh√°c nhau-> c·∫©n c·∫©n th·∫≠n v√¨ kh√≠ ki·ªÉm so√°t, ko bi·∫øt l√† object nh∆∞ th·∫ø n√†o.
  -C√≥ th·ªÉ d√πng try-catch ƒë·ªÉ b·∫Øt l·ªói tr√°nh crash app.
##H·∫±ng s·ªë (const, readonly)
-Const: ph·∫£i g√°n gi√° tr·ªã ngay khi khai b√°o, ko th·ªÉ s·ª≠a l·∫°i gi√° tr·ªã
  Tr√¨nh bi√™n d·ªãch s·∫Ω d√πng lu√¥n(nh√∫ng lu√¥n) gi√° tr·ªã ƒë√≥ cho v√†o bi√™n d·ªãch-> ph·∫£i rebuild l·∫°i th√¨ m·ªõi thay ƒë·ªïi ƒë∆∞·ª£c
  => ch·∫°y s·∫Ω nhanh h∆°n bi·∫øn th∆∞·ªùng v√¨ d·ª´ng gi√° tr·ªã tr·ª±c ti·∫øp ko th√¥ng qua bi·∫øn n√†o c·∫£.
-readonly: Ko nh·∫•t thi·∫øt ph·∫£i g√°n gi√° tr·ªã ngay sau khi khai b√°o, CH·ªà c√≥ th·ªÉ kh·ªüi t·∫°o gi√° tr·ªã t·∫°i l√∫c khai b√°o ho·∫∑c ·ªü contructor, sau ƒë√≥ c≈©ng ko th·ªÉ thay ƒë·ªïi

3. To√°n t·ª≠
To√°n t·ª≠ s·ªë h·ªçc: +, -, *, /, %

To√°n t·ª≠ so s√°nh: ==, !=, >, <, >=, <=

To√°n t·ª≠ logic: &&, ||, !

To√°n t·ª≠ g√°n: =, +=, -=, ...

Ternary (? :), Null-coalescing (??, ??=)
-??: n·∫øu tr√°i null th√¨ d√πng ph·∫£i: x ?? "default"
-??=:n·∫øu tr√°i null th√¨ g√°n ph·∫£i v√†o: x ??= "default": n·∫øu x null th√¨ x g√°n b·∫±ng "default"
is, as, typeof, sizeof
-is: ki·ªÉm tra xem c√≥ ph·∫£i ki·ªÉu c·ª• th·ªÉ ko,
-as: √©p ki·ªÉu an to√†n ko b·∫Øn ra exception, ch·ªâ cho null n·∫øu sai
-typof: l·∫•y type c·ªßa object: d√πng trong relection
-sizeof: l·∫•y ra s·ªë byte c·ªßa ki·ªÉu d·ªØ li·ªáu

4. C√¢u l·ªánh ƒëi·ªÅu ki·ªán & v√≤ng l·∫∑p
if, else if, else
switch, case, default
for, while, do-while, foreach
break, continue, return
5. M·∫£ng v√† chu·ªói
M·∫£ng m·ªôt chi·ªÅu, nhi·ªÅu chi·ªÅu, jagged array

C√°c thao t√°c tr√™n string: Substring, IndexOf, Split, Replace, Trim, ...
-string: immutable l√† b·∫•t 
-StringBuilder: x·ª≠ l√Ω chu·ªói hi·ªáu qu·∫£ khi c·∫ßn  n·ªëi nhi·ªÅu chu·ªói, x·ª≠ l√Ω l·∫∑p l·∫°i nhi·ªÅu l·∫ßn
  +Kh√¥ng c√≥ t·∫°o ra v√πng nh·ªõ m·ªõi m√† l√†m vi·ªác tr∆∞·ª£c ti·∫øp tr√™n v√πng nh·ªõ hi·ªán t·∫°i
  +Kh√¥ng thead-safe do l√† mutable

üü° II. L·∫≠p tr√¨nh h∆∞·ªõng ƒë·ªëi t∆∞·ª£ng (OOP)
6. Class v√† Object
Khai b√°o class, t·∫°o ƒë·ªëi t∆∞·ª£ng b·∫±ng new

Constructor (m·∫∑c ƒë·ªãnh, c√≥ tham s·ªë, static)
+static contructor: ko c√≥ tham s·ªë, ko accessmodifier, ko g·ªçi tr·ª±c ti·∫øp, ch·ªâ g·ªçi 1 l·∫ßn khi instance c·ªßa class dk t·∫°o ho·∫∑c c√≥ th√†nh vi√™n static kh√°c dk g·ªçi.
-> d√πng khi c·∫ßn kh·ªüi t·∫°o gi√° tr·ªã static ban ƒë·∫ßu
Field, Property, Method
-Field: l√† 1 tr∆∞·ªùng khai b√°o ƒë·ªÉ l∆∞u d·ªØ th√¥ng tin, l√† bi·∫øn th√¥, √≠t ki·ªÉm so√°t
-Poperty: d√πng bao b·ªçc field, ki·ªÉm so√°t vi·ªác g√°n ƒë·ªçc ghi:
    class Person
    {
        private int age;//field
        private string Name;//field
        public int Age//property
        {
            get { return age; }
            set
            {
                if (value >= 0) age = value;
            }
        }
        public string Name {get;set;}//property-> // compiler t·ª± t·∫°o field ·∫©n cho name
    }

7. T√≠nh ƒë√≥ng g√≥i (Encapsulation)
Access modifiers: public, private, protected, internal, protected internal

8. T√≠nh k·∫ø th·ª´a (Inheritance)
K·∫ø th·ª´a class (:)

base keyword

9. T√≠nh ƒëa h√¨nh (Polymorphism)
#Ghi ƒë√® method (virtual, override)
  -X·∫£y ra t·∫°i runtime
  -X·∫£y ra khi k·∫ø th·ª©, con k·∫ø th·ª´a cha v√† mu·ªën ghi thay ƒë·ªïi ho·∫°t ƒë·ªông c·ªßa m·ªôt ph∆∞∆°ng th·ª©c
  -Gi·ªØ nguy√™n t√™n, tham s·ªë ch·ªâ thay ƒë·ªïi h√†nh vi
  -h√†m ·ªü cha ph·∫£i c√≥ virtual method, abtract method, ·ªü con d√πng override ƒë·ªÉ ƒë√°nh ƒë√¢u ghi ƒë√® ph∆∞∆°ng th·ª©c
Virtual VS abtract
-virtual l√† kh√°i ni·ªám ch·ªâ cho method, ƒë√°nh ƒë·∫•u method ƒë√≥ c√≥ th·ªÉ ƒë∆∞·ª£c override l·∫°i ·ªü class con(tu·ª≥ ch·ªçn), v√¨ virtual method c√≥ s·∫µn th√¢n h√†m {}> c√≥ th·ªÉ d√πng lu√¥n khi ·ªü l·ªõp cha.
  +virual l√† c·ªßa method, method n√†y n·∫±m trong 1 class th∆∞·ªùng(ko c√≥ virtual class)-> c√≥ th·ªÉ kh·ªüi t·∫°o ƒë·ªëi t∆∞·ªùng t·ª´ l·ªõp cha b√¨nh th∆∞·ªùng nh∆∞ bao class kh√°c.
-Abtract: abtract method l√† khai b√°o method ko c√≥ th√¢n h√†m{}-nghƒ©a l√† ch∆∞a impliement j, l·ªõp con b√°t bu·ªôc ph·∫£i d√πng override v√† tri·ªÉn khai h√†m n√†y.
    +Khi 1 class c√≥ √≠t nh·∫•t 1 abtract method th√¨ class ƒë√≥ c≈©ng ph·∫£i khai b√°o l√† abtract class-> ko th·ªÉ kh·ªüi t·∫°i ƒë·ªëi t∆∞·ª£ng ƒë∆∞·ª£c
      -> abtract class ch·ªâ l√† l·ªõp tr·ª´u t∆∞·ª£ng-ƒë·ªãnh h∆∞·ªõng cho c√°c l·ªõp con tri·ªÉn khai c·ª• th·ªÉ.
#N·∫°p ch·ªìng method (overload)

10. T√≠nh tr·ª´u t∆∞·ª£ng (Abstraction)
Abstract class & method
  -CH·ªâ th·ªÉ hi·ªán ra nghi·ªáp v·ª• ch√≠nh, ko th·ªÉ hi·ªán x·ª≠ l√Ω logic ph·ª©c t·∫°p
Interface

11. Static vs Instance
Static method, property, class
-Static l√† th√†nh vi√™n thu·ªôc class ch·ª© ko thu·ªôc v·ªÅ 1 instance n√†o c·ª• th·ªÉ. G·ªçi tr·ª±c ti·∫øp t·ª´ class ra.
So s√°nh v·ªõi non-static
  +no-static l√† th√†nh ph·∫ßn thu·ªôc v·ªÅ instance. sau khi t·∫°o instance th√¨ m·ªõi s·ª≠ d·ª•ng dk, v√† s·ª≠ d·ª•ng c√πng v·ªõi instance.

üîµ III. C·∫•u tr√∫c n√¢ng cao trong C#
12. Struct v√† Enum
Khai b√°o struct

Enum v√† c√°ch s·ª≠ d·ª•ng

13. Nullable v√† Null Safety
Nullable<T> v√† ?

??, ?., ??=, ! (null-forgiving)

14. Tuple & ValueTuple
-Tuple vs ValueTuple: ph√¢n t·ª≠ gi√∫p tr·∫£ v·ªÅ nhi·ªÅu gi√° tr·ªã t·ª´ method ho·∫∑c l∆∞u tr·ªØ nh√≥m d·ªØ li·ªáu t·∫°m t·ªùi m√† ko c·∫ßn ƒë·ªãnh nghƒ©a class.
  Kh√°c v·ªõi class v√† struct ·ªü ch·ªó khi nu·ªëm d·ªØ li·ªáu logic ri√™ng v√† t·ªï ch·ª©c r√µ r√†ng
  +Tuple l√† c≈© h∆°n -immutable, l∆∞u tr√™n heap v√¨ c√≥ c·∫•u tr√∫c l√† class, ko th·ªÉ ƒë·∫∑t th√™n, truy c·∫≠p b·∫±ng .Item1, .Item2
    +Immutable v√¨ ch√∫ng ch·ªâ cho ph√©p ƒë·ªçc c√°c gi√° tr·ªã .item1, .item2 ch·ª© ko cho thay ƒë·ªïi-> l∆∞u d·ªØ li·ªáu ko th·ªÉ thay ƒë·ªïi ƒë∆∞·ª£c.
  +ValuTuple l√† m·ªõi h∆°n-mutable, l∆∞u tr√™n stack v√¨ c√≥ c·∫•u tr√∫c d·ªØ li·ªáu l√† struct, c√≥ th·ªÉ ƒë·∫∑t t√™n, truy c·∫≠p b·∫±ng .Item1;.Item2 ho·∫∑c t√™n ƒë·∫∑t
    -> t·∫°m gi·ªØ d·ªØ li·ªáu c√≥ th·ªÉ thay ƒë·ªïi ƒë∆∞·ª£c
(int, string), truy c·∫≠p b·∫±ng .Item1, ho·∫∑c ƒë·∫∑t t√™n

15. Record (C# 9+)
-record vs class: C√πng l√† ki·ªÉu tham chi·∫øu, ƒë·ªÅu c√≥ field, property, method, d√πng t·ª´ kh√°o new ƒë·ªÉ t·∫°o instance, c√≥ contructor
- class: d√πng cho c√°c object c√≥ c√°c h√†nh vi ph·ª©c t·∫°p
  + So s√°nh object l√† so s√°nh ƒë·ªãa ch·ªâ v·ªõi nhau-> c√πng ƒë·ªãa ch·ªâ th√¨ m·ªõi l√† b·∫±ng nhau.
  + ko h·ªó tr·ª£ clone(with)
-recode sinh l√† ƒë·ªÉ:
  + x·ª≠ l√Ω d·ªØ li·ªáu b·∫•t bi·∫øn, ƒë√£ ƒë∆∞∆°c override s·∫µn Equals()-so s√°nh field, == operator so s√°nh n·ªôi dung, with-t·∫°o b·∫£n clone
  +b·∫£n ch·∫•t v·∫´n l√† l∆∞u li·ªáu ref, v√† L∆∞u d·ªØ li·ªáu trong heap gi·ªëng class
  + h·ªó tr·ª£ so s√°nh theo gi√° tr·ªã thay v√¨ ƒë·ªãa ch·ªâ
  + h·ªó tr·ª£ clone(with)
          var p1 = new Person("Hai", 25);
          var p2 = p1 with { Age = 30 };
          Console.WriteLine(p2); // Person { Name = Hai, Age = 30 }, t·∫°o ra person m·ªõi c√≥ tu·ªïi kh√°c v·ªõi person c≈©
  +  H·ªó tr·ª£ m·∫∑c ƒë√¨nh l√† b·∫•t bi·∫øn khi khai b√°o d√πng init ho·∫∑c positional. c√≤n khi khai b√°o gi·ªëng class th√¨ l√† mutable
      public record User(string Name, int Age);//b·∫•t bi·∫øn, khai b√°o ki·ªÉu positional ng·∫Øn g·ªçn h∆°n khi d√πng init
      public string Name { get; init; }//b·∫•t bi·∫øn, ch·ªâ c√≥ th·ªÉ g√°n gi√° tr·ªã 1 l·∫ßn
      public int Age { get; init; }//b·∫•t bi·∫øn, ch·ªâ c√≥ th·ªÉ g√°n gi√° tr·ªã 1 l·∫ßn
      
      public record User
      {
          public string Name { get; set; }  // mutable!
      }

  + h·ªØu √≠ch DTO: do DTO ko n√™n b·ªã thay ƒë·ªïi sau khi t·∫°o ch·ªâ l√† g√≥i d·ªØ li·ªáu r·ªìi truy·ªÅn ƒëi, truy·ªÅn d·ªØ li·ªáu gi·ªØa c√°c t·∫ßng, m√¥ h√¨nh d·ªØ li·ªáu
- record struct l√† 1 valuetype v√† l∆∞u tr√™n stack-> ko b·∫•t bi·∫øn m·∫∑c ƒë·ªãnh

B·∫•t bi·∫øn (immutable objects)

16. Collections
List<T>, Dictionary<TKey, TValue>, HashSet<T>, Queue<T>, Stack<T>

foreach duy·ªát collection

IEnumerable<T> vs ICollection<T> vs IList<T>
public interface IEnumerable<out T>
{
    IEnumerator<T> GetEnumerator();
}

L√† cha ƒë·∫ª c·ªßa m·ªçi lo·∫°i t·∫≠p h·ª£p trong C#, d√πng ƒë·ªÉ duy·ªát ph·∫©n t·ª≠, ko c√≥ ch·ª©c nƒÉng n√†o kh√°c
-C√≥ s·∫µn d·ªØ li·ªáu ho·∫∑c ch·ªâ l√† c√¢u truy v·∫•n ch∆∞a c√≥ d·ªØ li·ªáu tr√™n RAM. ph·∫£i .ToList() th√¨ m·ªõi c√≥ d·ªØ li·ªáu tr√™n RAM
public interface ICollection<T> : IEnumerable<T>
{
    int Count { get; }
    bool IsReadOnly { get; }
    void Add(T item);
    bool Remove(T item);
    void Clear();
    bool Contains(T item);
    void CopyTo(T[] array, int arrayIndex);
}
-K·∫ø th·ª´a t·ª´ cha ƒë·∫ª IEnumable<T> v√† cung c·∫•p th√™m m·ªôt s·ªë t√≠nh nƒÉng: th√™m/s·ª≠a/x√≥a/, l√†m abtract cho c√°c list

public interface IList<T> : ICollection<T>
{
    T this[int index] { get; set; }
    int IndexOf(T item);
    void Insert(int index, T item);
    void RemoveAt(int index);
}
-L√† con c·ªßa ICollection<T> v√† th√™m c√°c t√≠nh nƒÉng: ch·ªâ s·ªë, truy c·∫≠p ch√®n/s·ª≠a/x√≥a theo ch·ªâ s·ªë
IQueryable<T>:D·ªãch c√¢u linq sang SQL, m√† ch∆∞a t·∫£i d·ªØ li·ªáu ngay, ph·∫£i d√πng Tolist th√¨ m·ªõi l·∫•y d·ªØ li·ªáu
IEnumerable<T>: ko d·ªãch linq sang SQL, n·∫øu tolist s·ªõm s·∫Ω l·∫•y h·∫øt d·ªØ li·ªáu ra RAM ƒë·∫ª x·ª≠ l√Ω
üü£ IV. X·ª≠ l√Ω ngo·∫°i l·ªá (Exception Handling)
17. Try-catch-finally
try, catch, finally

throw exception m·ªõi

C√°c lo·∫°i exception ph·ªï bi·∫øn: NullReferenceException, InvalidOperationException, ...

üî¥ V. LINQ v√† Lambda
18. Lambda expression
(x) => x * 2

19. LINQ c∆° b·∫£n
Where, Select, FirstOrDefault, OrderBy, GroupBy, Count, Any, All

üü§ VI. Delegate & Event
20. Delegate
ƒê·ªãnh nghƒ©a delegate

Truy·ªÅn method v√†o delegate

21. Event
ƒêƒÉng k√Ω v√† ph√°t s·ª± ki·ªán

EventHandler

‚ö™ VII. C√°c ch·ªß ƒë·ªÅ .NET c∆° b·∫£n
22. .NET v√† CLR
Kh√°i ni·ªám CLR, CTS, CLS
-CLR: Common language runtime: qu·∫£n l√Ω b·ªô nh·ªõ, thread/task, ngo·∫°i l·ªá, 
Bi√™n d·ªãch v√† IL:M√£ trung gian sau khi bi√™n d·ªãch
1. C# source code (.cs)
         |
         V
2. Compiler (csc.exe)
         |
         V
3. IL code (.dll, .exe)
         |
         V
4. CLR th·ª±c thi
    ‚Üí JIT d·ªãch IL sang m√£ m√°y
         |
         V
5. ·ª®ng d·ª•ng ch·∫°y tr√™n Windows/Linux/Mac

24. Attribute v√† Reflection
[Obsolete], [Serializable], [Required], custom attribute

Type.GetProperties(), GetCustomAttributes()

25. File I/O c∆° b·∫£n
ƒê·ªçc/Ghi file v·ªõi File, StreamReader, StreamWriter

26. Datetime v√† Timer
DateTime, TimeSpan, Stopwatch, Timer

30. System.Text.Json vs Newtonsoft.Json:
-System.Text.Json: ƒë∆∞·ª£c t√≠ch h·ª£p s·∫µn, hi·ªáu nƒÉng cao h∆°n nh∆∞ng √≠t t√πy bi·∫øn h∆°n, ko h·ªó tr·ª£ tr·ª±c ti·∫øp dynamic(ph·∫£i d√πng D√πng JsonDocument (ph·ª©c t·∫°p h∆°n, d·∫°ng DOM t∆∞∆°ng t·ª± XML): code d√†i v√† ph·ª©c t·∫°p h∆°n)
-Newtonsoft.Json: c√†i nuget, c√≥ nhi·ªÅu t√πy bi·∫øn, h·ªó tr·ª£ ki·ªÉu dynamic: g·ªçi ra nh∆∞ object thu·∫≠n ti·ªán s·ª≠ d·ª•ng.
